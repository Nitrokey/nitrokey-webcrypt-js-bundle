// Copyright 2022 Nitrokey GmbH
//
// Licensed under the Apache License, Version 2.0, <LICENSE-APACHE or
// http://apache.org/licenses/LICENSE-2.0> or the MIT license <LICENSE-MIT or
// http://opensource.org/licenses/MIT>, at your option. This file may not be
// copied, modified, or distributed except according to those terms.

// AUTOGENERATED'
import {StatusCallback} from "./types";
import {send_command} from "./transport";
import {WEBCRYPT_CMD} from "./constants";
import {Session} from "./session";
const session = new Session();

export type WebcryptData = string;


// CommandStatusParams
export class CommandStatusReturn {
    public UNLOCKED: boolean;
    public VERSION: WebcryptData;
    public SLOTS: WebcryptData;
    public PIN_ATTEMPTS: WebcryptData;
    constructor(UNLOCKED: boolean, VERSION: WebcryptData, SLOTS: WebcryptData, PIN_ATTEMPTS: WebcryptData) {
        this.UNLOCKED = UNLOCKED;
        this.VERSION = VERSION;
        this.SLOTS = SLOTS;
        this.PIN_ATTEMPTS = PIN_ATTEMPTS;
    }
}
export async function Webcrypt_Status(statusCallback: StatusCallback): Promise<CommandStatusReturn>{
    const res = await send_command(session, WEBCRYPT_CMD.STATUS, {}, statusCallback);
    return new CommandStatusReturn(res["UNLOCKED"], res["VERSION"], res["SLOTS"], res["PIN_ATTEMPTS"]);
}
export class CommandTestPingParams {
    public WebcryptData: WebcryptData;
    constructor(WebcryptData: WebcryptData) {
        this.WebcryptData = WebcryptData;
    }
}
export class CommandTestPingReturn {
    public WebcryptData: WebcryptData;
    constructor(WebcryptData: WebcryptData) {
        this.WebcryptData = WebcryptData;
    }
}
export async function Webcrypt_TestPing(statusCallback: StatusCallback, data: CommandTestPingParams): Promise<CommandTestPingReturn>{
    const res = await send_command(session, WEBCRYPT_CMD.TEST_PING, data, statusCallback);
    return new CommandTestPingReturn(res["WebcryptData"]);
}
// CommandTestClearParams
// CommandTestClearReturn
export async function Webcrypt_TestClear(statusCallback: StatusCallback): Promise<void>{
    const res = await send_command(session, WEBCRYPT_CMD.TEST_CLEAR, {}, statusCallback);
}
// CommandTestRebootParams
// CommandTestRebootReturn
export async function Webcrypt_TestReboot(statusCallback: StatusCallback): Promise<void>{
    const res = await send_command(session, WEBCRYPT_CMD.TEST_REBOOT, {}, statusCallback);
}
export class CommandLoginParams {
    public PIN: WebcryptData;
    constructor(PIN: WebcryptData) {
        this.PIN = PIN;
    }
}
export class CommandLoginReturn {
    public TP: WebcryptData;
    constructor(TP: WebcryptData) {
        this.TP = TP;
    }
}
export async function Webcrypt_Login(statusCallback: StatusCallback, data: CommandLoginParams): Promise<CommandLoginReturn>{
    const res = await send_command(session, WEBCRYPT_CMD.LOGIN, data, statusCallback);
    return new CommandLoginReturn(res["TP"]);
}
// CommandLogoutParams
// CommandLogoutReturn
export async function Webcrypt_Logout(statusCallback: StatusCallback): Promise<void>{
    const res = await send_command(session, WEBCRYPT_CMD.LOGOUT, {}, statusCallback);
}
// CommandFactoryResetParams
// CommandFactoryResetReturn
export async function Webcrypt_FactoryReset(statusCallback: StatusCallback): Promise<void>{
    const res = await send_command(session, WEBCRYPT_CMD.FACTORY_RESET, {}, statusCallback);
}
export class CommandSetConfigurationParams {
    public CONFIRMATION: WebcryptData;
    constructor(CONFIRMATION: WebcryptData) {
        this.CONFIRMATION = CONFIRMATION;
    }
}
// CommandSetConfigurationReturn
export async function Webcrypt_SetConfiguration(statusCallback: StatusCallback, data: CommandSetConfigurationParams): Promise<void>{
    const res = await send_command(session, WEBCRYPT_CMD.SET_CONFIGURATION, data, statusCallback);
}
// CommandGetConfigurationParams
export class CommandGetConfigurationReturn {
    public CONFIRMATION: WebcryptData;
    constructor(CONFIRMATION: WebcryptData) {
        this.CONFIRMATION = CONFIRMATION;
    }
}
export async function Webcrypt_GetConfiguration(statusCallback: StatusCallback): Promise<CommandGetConfigurationReturn>{
    const res = await send_command(session, WEBCRYPT_CMD.GET_CONFIGURATION, {}, statusCallback);
    return new CommandGetConfigurationReturn(res["CONFIRMATION"]);
}
export class CommandSetPinParams {
    public PIN: WebcryptData;
    constructor(PIN: WebcryptData) {
        this.PIN = PIN;
    }
}
// CommandSetPinReturn
export async function Webcrypt_SetPin(statusCallback: StatusCallback, data: CommandSetPinParams): Promise<void>{
    const res = await send_command(session, WEBCRYPT_CMD.SET_PIN, data, statusCallback);
}
export class CommandChangePinParams {
    public PIN: WebcryptData;
    public NEWPIN: WebcryptData;
    constructor(PIN: WebcryptData, NEWPIN: WebcryptData) {
        this.PIN = PIN;
        this.NEWPIN = NEWPIN;
    }
}
// CommandChangePinReturn
export async function Webcrypt_ChangePin(statusCallback: StatusCallback, data: CommandChangePinParams): Promise<void>{
    const res = await send_command(session, WEBCRYPT_CMD.CHANGE_PIN, data, statusCallback);
}
export class CommandInitializeSeedParams {
    public ENTROPY: WebcryptData;
    constructor(ENTROPY: WebcryptData) {
        this.ENTROPY = ENTROPY;
    }
}
export class CommandInitializeSeedReturn {
    public MASTER: WebcryptData;
    public SALT: WebcryptData;
    constructor(MASTER: WebcryptData, SALT: WebcryptData) {
        this.MASTER = MASTER;
        this.SALT = SALT;
    }
}
export async function Webcrypt_InitializeSeed(statusCallback: StatusCallback, data: CommandInitializeSeedParams): Promise<CommandInitializeSeedReturn>{
    const res = await send_command(session, WEBCRYPT_CMD.INITIALIZE_SEED, data, statusCallback);
    return new CommandInitializeSeedReturn(res["MASTER"], res["SALT"]);
}
export class CommandRestoreFromSeedParams {
    public MASTER: WebcryptData;
    public SALT: WebcryptData;
    constructor(MASTER: WebcryptData, SALT: WebcryptData) {
        this.MASTER = MASTER;
        this.SALT = SALT;
    }
}
export class CommandRestoreFromSeedReturn {
    public HASH: WebcryptData;
    constructor(HASH: WebcryptData) {
        this.HASH = HASH;
    }
}
export async function Webcrypt_RestoreFromSeed(statusCallback: StatusCallback, data: CommandRestoreFromSeedParams): Promise<CommandRestoreFromSeedReturn>{
    const res = await send_command(session, WEBCRYPT_CMD.RESTORE_FROM_SEED, data, statusCallback);
    return new CommandRestoreFromSeedReturn(res["HASH"]);
}
// CommandGenerateKeyParams
export class CommandGenerateKeyReturn {
    public PUBKEY: WebcryptData;
    public KEYHANDLE: WebcryptData;
    constructor(PUBKEY: WebcryptData, KEYHANDLE: WebcryptData) {
        this.PUBKEY = PUBKEY;
        this.KEYHANDLE = KEYHANDLE;
    }
}
export async function Webcrypt_GenerateKey(statusCallback: StatusCallback): Promise<CommandGenerateKeyReturn>{
    const res = await send_command(session, WEBCRYPT_CMD.GENERATE_KEY, {}, statusCallback);
    return new CommandGenerateKeyReturn(res["PUBKEY"], res["KEYHANDLE"]);
}
export class CommandSignParams {
    public HASH: WebcryptData;
    public KEYHANDLE: WebcryptData;
    constructor(HASH: WebcryptData, KEYHANDLE: WebcryptData) {
        this.HASH = HASH;
        this.KEYHANDLE = KEYHANDLE;
    }
}
export class CommandSignReturn {
    public SIGNATURE: WebcryptData;
    public INHASH: WebcryptData;
    constructor(SIGNATURE: WebcryptData, INHASH: WebcryptData) {
        this.SIGNATURE = SIGNATURE;
        this.INHASH = INHASH;
    }
}
export async function Webcrypt_Sign(statusCallback: StatusCallback, data: CommandSignParams): Promise<CommandSignReturn>{
    const res = await send_command(session, WEBCRYPT_CMD.SIGN, data, statusCallback);
    return new CommandSignReturn(res["SIGNATURE"], res["INHASH"]);
}
export class CommandDecryptParams {
    public DATA: WebcryptData;
    public KEYHANDLE: WebcryptData;
    public HMAC: WebcryptData;
    public ECCEKEY: WebcryptData;
    constructor(DATA: WebcryptData, KEYHANDLE: WebcryptData, HMAC: WebcryptData, ECCEKEY: WebcryptData) {
        this.DATA = DATA;
        this.KEYHANDLE = KEYHANDLE;
        this.HMAC = HMAC;
        this.ECCEKEY = ECCEKEY;
    }
}
export class CommandDecryptReturn {
    public DATA: WebcryptData;
    constructor(DATA: WebcryptData) {
        this.DATA = DATA;
    }
}
export async function Webcrypt_Decrypt(statusCallback: StatusCallback, data: CommandDecryptParams): Promise<CommandDecryptReturn>{
    const res = await send_command(session, WEBCRYPT_CMD.DECRYPT, data, statusCallback);
    return new CommandDecryptReturn(res["DATA"]);
}
export class CommandGenerateKeyFromDataParams {
    public HASH: WebcryptData;
    constructor(HASH: WebcryptData) {
        this.HASH = HASH;
    }
}
export class CommandGenerateKeyFromDataReturn {
    public PUBKEY: WebcryptData;
    public KEYHANDLE: WebcryptData;
    constructor(PUBKEY: WebcryptData, KEYHANDLE: WebcryptData) {
        this.PUBKEY = PUBKEY;
        this.KEYHANDLE = KEYHANDLE;
    }
}
export async function Webcrypt_GenerateKeyFromData(statusCallback: StatusCallback, data: CommandGenerateKeyFromDataParams): Promise<CommandGenerateKeyFromDataReturn>{
    const res = await send_command(session, WEBCRYPT_CMD.GENERATE_KEY_FROM_DATA, data, statusCallback);
    return new CommandGenerateKeyFromDataReturn(res["PUBKEY"], res["KEYHANDLE"]);
}
// CommandGenerateResidentKeyParams
export class CommandGenerateResidentKeyReturn {
    public PUBKEY: WebcryptData;
    public KEYHANDLE: WebcryptData;
    constructor(PUBKEY: WebcryptData, KEYHANDLE: WebcryptData) {
        this.PUBKEY = PUBKEY;
        this.KEYHANDLE = KEYHANDLE;
    }
}
export async function Webcrypt_GenerateResidentKey(statusCallback: StatusCallback): Promise<CommandGenerateResidentKeyReturn>{
    const res = await send_command(session, WEBCRYPT_CMD.GENERATE_RESIDENT_KEY, {}, statusCallback);
    return new CommandGenerateResidentKeyReturn(res["PUBKEY"], res["KEYHANDLE"]);
}
export class CommandReadResidentKeyPublicParams {
    public KEYHANDLE: WebcryptData;
    constructor(KEYHANDLE: WebcryptData) {
        this.KEYHANDLE = KEYHANDLE;
    }
}
export class CommandReadResidentKeyPublicReturn {
    public PUBKEY: WebcryptData;
    public KEYHANDLE: WebcryptData;
    constructor(PUBKEY: WebcryptData, KEYHANDLE: WebcryptData) {
        this.PUBKEY = PUBKEY;
        this.KEYHANDLE = KEYHANDLE;
    }
}
export async function Webcrypt_ReadResidentKeyPublic(statusCallback: StatusCallback, data: CommandReadResidentKeyPublicParams): Promise<CommandReadResidentKeyPublicReturn>{
    const res = await send_command(session, WEBCRYPT_CMD.READ_RESIDENT_KEY_PUBLIC, data, statusCallback);
    return new CommandReadResidentKeyPublicReturn(res["PUBKEY"], res["KEYHANDLE"]);
}
// CommandDiscoverResidentKeysParams
// CommandDiscoverResidentKeysReturn
export async function Webcrypt_DiscoverResidentKeys(statusCallback: StatusCallback): Promise<void>{
    const res = await send_command(session, WEBCRYPT_CMD.DISCOVER_RESIDENT_KEYS, {}, statusCallback);
}
export class CommandWriteResidentKeyParams {
    public RAW_KEY_DATA: WebcryptData;
    constructor(RAW_KEY_DATA: WebcryptData) {
        this.RAW_KEY_DATA = RAW_KEY_DATA;
    }
}
export class CommandWriteResidentKeyReturn {
    public PUBKEY: WebcryptData;
    public KEYHANDLE: WebcryptData;
    constructor(PUBKEY: WebcryptData, KEYHANDLE: WebcryptData) {
        this.PUBKEY = PUBKEY;
        this.KEYHANDLE = KEYHANDLE;
    }
}
export async function Webcrypt_WriteResidentKey(statusCallback: StatusCallback, data: CommandWriteResidentKeyParams): Promise<CommandWriteResidentKeyReturn>{
    const res = await send_command(session, WEBCRYPT_CMD.WRITE_RESIDENT_KEY, data, statusCallback);
    return new CommandWriteResidentKeyReturn(res["PUBKEY"], res["KEYHANDLE"]);
}

